package introduction;
import java.util.Scanner;
public class Main3 {
/**		K好数	(动态规划)
 *	时间限制：1.0s   内存限制：256.0MB
 *	 问题描述
 *		如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。
 *		求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。
 *		由于这个数目很大，请你输出它对1000000007取模后的值。
 *	输入格式
 *	输入包含两个正整数，K和L。
 * 	输出格式
 *	输出一个整数，表示答案对1000000007取模后的值。
 * 	样例输入
 *	4 2
 * 	样例输出
 *	7
 * 	数据规模与约定
 *	 对于30%的数据，KL <= 106；
 *
 *	对于50%的数据，K <= 16， L <= 10；
 *
 *	对于100%的数据，1 <= K,L <= 100。
 * 	时间	125ms
 * 	内存	23.81MB
 * 	解析 ：什么是k好数呢 比如说 4进制 2位数的数值  有 00，01，02，03，10，11，12，13，20，21，22，23，30，31，32，33
 * 		其中只有00，02，03，11，13，20，22，30，31，33满足两个数互不相邻由于第一位不能位0 所以就有7个数满足要求
 * 		我们通过一个二维数组 来完成此题 dp[i][j] i表示i位数 j表示进制  ，根据动态规划 先从一位数开始 然后二位数 三位数 .......
 * 		当计算i位数的时候只要满足两个数满足条件 则 i位数也和i-1位数满足 所以直接加上满足i-1位的数个数（有点乱...）
 * */
	public static long  mod = 1000000007;	//模
	public static long dp[][] = new long[505][505];	//dp[i][j] i表示位数 j 表示进制 如4 2 则 i 为 1，2 j为 0，1，2，3
	public static void main(String[] args) {
		long sum = 0;
		int i,j,x;
		Scanner sca = new Scanner(System.in);
		int k = sca.nextInt();
		int l = sca.nextInt();
		for(i=0;i<k;i++)	//当一位数时直接满足条件所以全赋值为一
			dp[1][i] = 1;
		for(i=2;i<=l;i++)
			for(j=0;j<k;j++) 
				for(x=0;x<k;x++) { 
					if(x!=j-1 && x!=j+1) {	//如果满足不与前面相邻同时也不与后一位相邻
						dp[i][j] += dp[i-1][x];		//加上i-1位的个数
						dp[i][j] %= mod;
					}	
				}
		for(i=1;i<k;i++) {
			sum += dp[l][i];	//相加
			sum %= mod;		//取模
		}
		System.out.println(sum);
	}
}
